# coding: utf-8

'''
東京の下町に長テーブルで有名な老舗うなぎ屋がありました。
そのうなぎ屋にはとても大きい長テーブルがあり、テーブルの周りにn個の座席が配置されています。
座席には、時計回りに1, 2, …, nと番号が振られています。
座席はテーブルの周りに配置されているので、座席番号nの座席と1の座席は隣接しています。（下記図を参照の事）
今、m個のグループの人達が座席に順番に座りに来ます。i番目(1≦i≦m)のグループの人数をa_i人とします。
彼らは、長テーブルに並んだ座席の内、ある連続するa_i個の座席に一斉に座ろうとします。
ただしお客さんは江戸っ子なので、それら座席のうち、いずれか一つでも既に先客に座られている座席があった場合、
一人も座らずにグループ全員で怒って帰ってしまいます。江戸っ子は気が早いんでぃ。
入力では、i番目のグループが座ろうとする連続した座席の位置は、整数b_iにより指定されます。
i番目のグループは、座席番号b_iの座席を始点として、そこから時計回りにa_i個分の座席に座ろうとします。
最後のグループが座りに来た後、無事に長テーブルの座席に着席出来ている人数を出力するプログラムを作成してください。

入力される値
入力はm+1行から成ります。
1行目にはn(座席数)とm(グループ数)が半角スペース区切りで入力されます。
i+1行目(1≦i≦m)には2個の整数a_i(グループの人数)とb_i(着席開始座席番号)が半角スペース区切りで入力されます。
入力値最終行の末尾に改行が１つ入ります。 
文字列は標準入力から渡されます。 標準入力からの値取得方法はこちらをご確認ください

期待する出力
最後のグループが座りに来た後、無事に座席に着席出来ている人数を1行で出力してください。
'''

Snum, Gnum = map(int,raw_input().split())
data = []
for i in range(Gnum):
    data.append(map(int, raw_input().split()))

seat = [0]*Snum
pre_seat = []

#各グループごとにseat情報を保存し、席がかぶったときは前のseat情報をリロードする
for j in range(Gnum):
    pre_seat = seat[:]
    for mem in range(data[j][0]):
        if  seat[(data[j][1]-1+mem)%(Snum)] == 0:
            seat[(data[j][1]-1+mem)%(Snum)] = 1
        else:
            seat = pre_seat
            break
        #print pre_seat
        #print seat
print sum(seat)        


'''
ポイント
pre_seat=seat[:]のところでpre_seat=seatとしてしまうと、pre_seatとseatが同一のものと扱われ、
seatの値が変わるたびにpre_seatの値も変更されてしまう
→pre_seat=seat[:]と書くと配列コピーになるので、seatが変更されてもpre_seatは元の値を保持する
'''